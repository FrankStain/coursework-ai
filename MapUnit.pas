unit MapUnit;
(**
 * Модуль карты. Содержит все необходимые классы для поддержки поля игры "Пятнашки".
 *
 * Содержимое модуля:
 *   TMap         - класс карты для пятнашек
 *   TMapSpaceRow - тип строки игрового поля, одномерный массив
 *   TMapSpace    - тип игрового поля, двухмерный массив
 *
 *   arMoveDirections - константа, содержащая 4 относительных шага
 *
 *)
interface

uses
  Windows, Classes, SysUtils;

Type
  // тип строки поля, вектор (одноменрый массив)
  TMapSpaceRow = array of byte;
  // тип поля, матрица (двухмерный массив)
  TMapSpace = array of TMapSpaceRow;

  (**
   * Класс карты игры.
   *
   * Представляет из себя матрицу X:X элементов с числами от 0 до (X^2 - 1)
   * Есть возможность задать карту размерностью от 3х3 до 5х5
   *
   *)
  TMap = class
    Private
      // Ссылка на карту источник (seed - сид - проросток)
      FSeed: TMap;
      // Список копий (пиров - пар, иными словам) текущей карты
      // Если делается копия от копии натуральной карты, то и эта копия заносится в список натуральной карты
      FPeers: TList;

      // Поле карты, двухмерный массив
      FMap: TMapSpace;
      // Ширина карты
      FWidth: integer;
      // Высота карты
      FHeight: integer;

    Protected
      // Возвращает номер фишки в ячейке по определенным координатам
      Function GetCell(X, Y: integer): byte;
      // Позволяет записать номер фишки в определенную ячейку карты
      Procedure SetCell(X, Y: integer; Value: byte);

    Public
      // Основной конструктор
      Constructor Create;              overload;
      // Конструктор копирования
      Constructor Create(oSeed: TMap); overload;
      // Дестркутор
      Destructor Destroy; override;

      // Осуществляет полный перенос данных с одной карты на другую
      Procedure Assign(oSource: TMap);
      // Позволяет изменить размер карты
      Function SetSize(X, Y: integer): boolean;
      // Выполняет проверку, возможно ли передвинуть фишку по определенным координатам
      Function IsCellMovable(X, Y: integer): boolean;
      // Выполняет перемещение фишки по заданным координатам, если такое возможно
      Function MoveCell(X, Y: integer): boolean;
      // Выполняет проверку достижимости условия конца игры
      Function IsValid: boolean;
      // Возвращает позицию пустой клетки на карте
      Function GetEmptyCell: TPoint;
      // Создает копию карты
      Function Peer: TMap;
      // Удаляет все копии ткущей карты
      Procedure ClearPeers;

      // Свойство ширины поля
      Property Width: integer read FWidth;
      // Свойство высоты поля
      Property Height: integer read FHeight;
      // Позволяет оперировать с ячейками поля по их координатам
      Property Cell[X, Y: integer]: byte read GetCell write SetCell;
      // Возвращает матриуц поля
      Property Space: TMapSpace read FMap;
  end;

const
  // сожержит относительные смещения координат пустой клетки для совершения шага
  arMoveDirections: array [0..3, 0..1] of smallint = (
    (1, 0), (0, 1), (-1, 0), (0, -1)
  );

implementation

(**
 * Конструктор карты. Производит первичную инициализацию полей карты.
 *
 *)
Constructor TMap.Create;
begin
  inherited;
  FSeed := nil;
  FPeers := nil;
  SetSize(3, 3);
end;

(**
 * Конструктор копирования, создает карту - копию другой карты
 *
 * Параметры:
 *   oSeed - Источник для создаваемой копии
 *)
Constructor TMap.Create(oSeed: TMap);
begin
  inherited Create;
  // Определяем хозяина для копии
  FSeed := oSeed;
  // Теперь переносим список копий в саму копию, это важно,
  // копия от этой копии тоже будет копией карты-источника, это нужно, чтоб не плодить списки копий
  FPeers := oSeed.FPeers;
  // Переносим к себе все данные из источника
  Assign(oSeed);
end;

(**
 * Деструктор объекта карты. Вычищает всю динамически выделенную память.
 *
 *)
Destructor TMap.Destroy;
begin
  // Если есть копии - чистим их
  ClearPeers;
  // Чистим память под поле
  Finalize(FMap);
  // Удаляемся... в прямом смысле О__о
  inherited;
end;

(**
 * Позволяет задать размеры карты
 *
 * Параметры:
 *   X - новая ширина карты
 *   Y - новая высота карты
 *
 * Возвращаемое значение:
 *   Возвращает true тогда, когда произошла удачная смена размера
 *
 *)
Function TMap.SetSize(X, Y: integer): boolean;
begin
  // Иициализация результата
  Result := false;
  // Если карта уже была задана, чистим занимаемую ей память
  if assigned(FMap) then Finalize(FMap);
  // Если заданные параметры не удовлетворяют некоторым условиям, то выходим с отрицательным результатом
  if (X < 3) or (X > 5) then exit;
  if (Y < 3) or (Y > 5) then exit;
  // Задаем внутренние переменные
  FWidth := X;
  FHeight := Y;
  // Выделяем память под карту нужных размеров и выходим с положительным результатом
  SetLength(FMap, FHeight, FWidth);
  Result := true;
end;

(**
 * Возвращает значение номерка фишки в клетке с заданными координатами
 *
 * Параметры:
 *   X - координата клетки по горизонтали
 *   Y - координата клетки по вертикали
 *
 * Возвращаемое значение:
 *   Если введены нормальные координаты - вернет вменяемое значение фишки,
 *   0 символизирует пустую клетку.
 *   Если введены недопустимые координаты - возвращает заведомо громадное значение,
 *   недопустимый номер фишки.
 *
 *)
Function TMap.GetCell(X, Y: integer): byte;
begin
  // Инициализируемся не весть каким большим значением, просто абы напугать
  Result := 255;
  // Если нам переданы ереальные координаты, то выходим и смело начинаем пугать тем самым значением
  if (X < 0) or (X >= FWidth) then exit;
  if (Y < 0) or (Y >= FHeight) then exit;
  // Определяем значение по введенным координатам
  Result := FMap[Y, X];
end;

(**
 * Производит запись номерка фишки в клетку с заданными координатами клетку
 *
 * Параметры:
 *   X - координата клетки по горизонтали
 *   Y - координата клетки по вертикали
 *   Value - номерок фишки, который надо записать
 *
 *)
Procedure TMap.SetCell(X, Y: integer; Value: byte);
begin
  // Если переданы нереальные координаты - просто выходим
  if (X < 0) or (X > FWidth) then exit;
  if (Y < 0) or (Y > FHeight) then exit;
  // производим установку фишки в клетку
  FMap[Y, X] := Value;
end;

(**
 * Выполняет проверку, можно ли переместить фишку по введенным координатам.
 *
 * Параметры:
 *   X - координата требуемой фишки по горизонтали
 *   Y - координата требуемой фишки по вертикали
 *
 * Возвращаемое значение:
 *   Возвращает true, если фишка по координатам может быть передвинута
 *
 *)
Function TMap.IsCellMovable(X, Y: integer): boolean;
begin
  // Инициализации отрицательным результатом
  Result := false;
  // Если переданные координаты вообще вне поля - выходим с плохим результатом
  if (X < 0) or (X >= FWidth) then exit;
  if (Y < 0) or (Y >= FHeight) then exit;
  // по правилу <ИЛИ> определяем, содержится ли нолик в одной из четырех соседних клеток?
  // Если нолик где-то там есть, то результат станет true, а иначе - все так же false.
  Result := (
    (Cell[X + 1, Y] = 0) or (Cell[X, Y + 1] = 0) or
    (Cell[X - 1, Y] = 0) or (Cell[X, Y - 1] = 0)
  );
end;

(**
 * Осуществляет, если возможно, перемещение фишки по заданным координатам на пустую клетку
 *
 * Параметры:
 *   X - координата требуемой фишки по горизонтали
 *   Y - координата требуемой фишки по вертикали
 *
 * Возвращаемое значение:
 *   Возвращает true, если ход удалось сделать, иначе вернет false
 *
 *)
Function TMap.MoveCell(X, Y: integer): boolean;
var
  iDirection, dx, dy: integer;
begin
  // Инициализируем результат
  Result := false;
  // Если введены недопустимые координаты, то выходим с отрицательным результатом
  if not IsCellMovable(X, Y) then exit;
  // перебираем 4 возможных варианта хода
  for iDirection := 0 to 3 do begin
    // Вычисляем координаты соседней клетки
    dx := X + arMoveDirections[iDirection, 0];
    dy := Y + arMoveDirections[iDirection, 1];
    // Если по этим координатам клетка пуста - делаем ход
    if GetCell(dx, dy) = 0 then begin
      // Записываем на координатах пустой клетки номер фишки
      SetCell(dx, dy, GetCell(X, Y));
      // А в клетку с фишкой записываем пустоту, теперь эта клетка пустая
      SetCell(X, Y, 0);
      // Результат делаем удачным и обрываем цикл ходов.
      Result := true;
      break;
    end;
  end;
end;

(**
 * Создает копию текущей карты
 *
 * Возвращаемое значение:
 *   Возвращается карта, являющаяся непосредственой копией текущей карты
 *
 *)
Function TMap.Peer: TMap;
begin
  // Если списка копий (пиров) нету, то создаем его
  if FPeers = nil then FPeers := TList.Create;

  // Создаем карту - копию
  Result := TMap.Create(self);
end;

(**
 * Очищает карту, содержащую копии, от копий.
 *
 *)
Procedure TMap.ClearPeers;
var
  iPeerId: integer;
begin
  // Если у нас есть породлающая карта, то мы - копия, нам в этом методе делать нечего.
  if (FPeers = nil) or (FSeed <> nil) then exit;
  // Производим очистку себя от своих копий
  for iPeerId := 0 to FPeers.Count - 1 do  TMap(FPeers.Items[iPeerId]).Free;
  // Удаляем и обнуляем список копий.
  FPeers.Free;
  FPeers := nil;
end;

(**
 * Проверяет, достигнуто ли условие конца игры.
 *
 * Метод вернет в результате true только тогда, когда все фишки на поле
 * будут расставлены по порядку и пустая ячейка будет в правом нижнем углу.
 *
 * Возвращаемое значение:
 *   Вернет true только если все фишки на поле упорядочены
 *)
Function TMap.IsValid: boolean;
var
  x, y: integer;
begin
  // Изначально считаем, что все фишки выставлены верно
  Result := true;

  // Если хоть одна фишка буде тне на месте - Result станет в false и циклы самы оборвутся
  y := 0;
  while Result and (y < FHeight) do begin
    x :=0;
    while Result and (x < FWidth) do begin
      // Правую нижнюю клетку никогда не проверяем, там можно найти фишку только
      // если они не упорядочены, в упорядоченном поле там всегда стоит пустая клетка
      if not (((x + 1) = FWidth) and ((y + 1) = FHeight)) then
        // Проверяем, стоит ли фишка на своем порядковом (y * FWidth + x) сесте?
        Result := FMap[y, x] = 1 + y * FWidth + x;
      inc(x);
    end;
    inc(y);
  end;
end;

(**
 * Возвращает координаты пустой клетки на поле
 *
 * Возвращаемое значение:
 *   Возвращает зпись типа TPoint, координаты (X, Y) по которым на поле стоит пустая клетка
 *
 *)
Function TMap.GetEmptyCell: TPoint;
var
  x, y: integer;
begin
  // Сначала координаты неизвесны
  Result := Point(-1, -1);
  for y := 0 to FHeight -1 do begin
    for x := 0 to FWidth - 1 do begin
      // Когда нашлась нулевая ячейка, возвращаем координаты и останавливаем циклы
      if FMap[y, x] = 0 then begin
        Result := Point(x, y);
        break;
      end;
    end;
  end;
end;

(**
 * Переносит состояние поля другой карты на текущую
 *
 * Параметры:
 *   oSource - Карта, состояние которой надо переписать на текущую карту.
 *)
Procedure TMap.Assign(oSource: TMap);
var
  x, y: integer;
begin
  // Изменяем свои размеры под размеры внешней карты
  SetSize(oSource.Width, oSource.Height);
  for y := 0 to FHeight -1 do begin
    for x := 0 to FWidth - 1 do begin
      // переписываем состояние ячейки из карты к себе
      FMap[y, x] := oSource.Cell[x, y];
    end;
  end;
end;

end.
